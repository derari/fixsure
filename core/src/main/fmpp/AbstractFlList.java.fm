// generated code
package org.cthul.fixsure.base;

import java.util.AbstractList;
import org.cthul.fixsure.Converter;
import org.cthul.fixsure.Fetcher;
import org.cthul.fixsure.Generator;
import org.cthul.fixsure.Sequence;
import org.cthul.fixsure.Values;
import org.cthul.fixsure.fluents.FlFetcher;
import org.cthul.fixsure.fluents.FlGenerator;
import org.cthul.fixsure.fluents.FlSequence;
import org.cthul.fixsure.fluents.FlValues;

/**
 *
 */
public abstract class AbstractFlList<T> 
                extends AbstractList<T> 
                implements FlSequence<T> {

    protected abstract FlSequence<T> generator();

    // Generator

<@fl "T", "next", [], [] />

    // FlGenerator

<@fl "FlValues<T>", "get", ["Generator<Integer>"], ["length"] />
<@fl "Values<T>", "get", ["Fetcher"], ["fetcher"] />
<@fl "FlValues<T>", "get", ["FlFetcher"], ["fetcher"] />
<@fl "FlValues<T>", "unbound", [], [] />
<@fl "FlValues<T>", "next", ["int"], ["length"] />
<@fl "FlValues<T>", "next", ["Generator<Integer>"], ["length"] />
<@fl "FlValues<T>", "all", [], [] />
<@fl "<T2> FlGenerator<T2>", "each", ["Converter<? super T, T2>"], ["converter"] />
<@fl "<T2> FlGenerator<T2>", "mergeWith", ["Generator<? extends T2>..."], ["generators"] />
<@fl "<T2> FlGenerator<T2>", "mixWith", ["Generator<? extends T2>..."], ["generators"] />
<@fl "<T2> FlGenerator<T2>", "alternateWith", ["Generator<? extends T2>..."], ["generators"] />
<@fl "FlGenerator<T>", "repeat", [], [] />
<@fl "<T2> FlGenerator<T2>", "invoke", ["String"], ["m"] />
<@fl "<T2> FlGenerator<T2>", "invoke", ["String", "Object..."], ["m", "args"] />

    // FlSequence

<@fl "<T2> FlSequence<T2>", "alternateWith", ["Sequence<? extends T2>..."], ["sequences"] />
<@fl "FlGenerator<T>", "shuffle", [], [] />
<@fl "FlGenerator<T>", "random", [], [] />

}
<#macro fl rType name pTypes pNames>
    /** {@inheritDoc} */
    @Override
    public ${rType} ${name}(<@params pTypes pNames />) {
        return generator().${name}(<@args pNames />);
    }

</#macro>
<#macro params pTypes pNames>
<#if (pTypes?size > 0)><#list 0..pTypes?size-1 as i><#if (i > 0)>, </#if>${pTypes[i]} ${pNames[i]}</#list></#if></#macro>
<#macro args names>
<#list names as n><#if (n_index > 0)>, </#if>${n}</#list></#macro>